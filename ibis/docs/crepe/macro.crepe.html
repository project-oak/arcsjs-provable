<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The main macro, which lets you write a Datalog program declaratively."><title>crepe in crepe - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9ee3a5e31a2afa3e.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="crepe" data-themes="" data-resource-suffix="" data-rustdoc-version="1.75.0 (82e1608df 2023-12-21)" data-channel="1.75.0" data-search-js="search-8fbf244ebcf71464.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-9dd44ab47b99a0fb.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../crepe/index.html">crepe</a><span class="version">0.1.6</span></h2></div><div class="sidebar-elems"></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Macro <a href="index.html">crepe</a>::<wbr><a class="macro" href="#">crepe</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/crepe/lib.rs.html#269">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>crepe!() { /* proc-macro */ }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The main macro, which lets you write a Datalog program declaratively.</p>
<h2 id="example"><a href="#example">Example</a></h2>
<p>A program to calculate transitive closure might be written as:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">mod </span>datalog {
    <span class="kw">use </span>crepe::crepe;

    <span class="macro">crepe! </span>{
        @input
        <span class="kw">struct </span>Edge(i32, i32);

        @output
        <span class="kw">struct </span>Tc(i32, i32);

        Tc(x, y) &lt;- Edge(x, y);
        Tc(x, z) &lt;- Edge(x, y), Tc(y, z);
    }

    <span class="kw">pub fn </span>run(edges: <span class="kw-2">&amp;</span>[(i32, i32)]) -&gt; Vec&lt;(i32, i32)&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>runtime = Crepe::new();
        runtime.extend(edges.iter().map(|<span class="kw-2">&amp;</span>(a, b)| Edge(a, b)));
        <span class="kw">let </span>(tc,) = runtime.run();
        tc.into_iter().map(|Tc(a, b)| (a, b)).collect()
    }
}</code></pre></div>
<h2 id="generated-code"><a href="#generated-code">Generated Code</a></h2>
<p>Each <code>struct</code> in the program is turned into a Datalog relation, while each
line of the form <code>goal &lt;- clause1, clause2, ...;</code> or <code>fact;</code> defines a
logic programming rule that is used to derive new relations.</p>
<p>In addition to the relation structs, the macro also defines a <code>Crepe</code>
struct representing the runtime. This is the primary way that you interact
with Crepe. It provides a couple methods and traits (here <code>Rel</code> is a
placeholder for the name of your relation):</p>
<ul>
<li><code>Crepe::new()</code>: construct a new runtime</li>
<li>Implements <code>std::iter::Extend&lt;Rel&gt;</code> for each @input struct.
<ul>
<li><code>Crepe::extend(&amp;mut self, iter: impl IntoIterator&lt;Item = Rel&gt;)</code></li>
</ul>
</li>
<li>Implements <code>std::iter::Extend&lt;&amp;'a Rel&gt;</code> for each @input struct.
<ul>
<li><code>Crepe::extend(&amp;mut self, iter: impl IntoIterator&lt;Item = &amp;'a Rel&gt;)</code></li>
</ul>
</li>
<li><code>Crepe::run(self)</code>: evaluates the Datalog program on the given inputs,
consuming the runtime object, and returns a tuple of <code>HashSet&lt;Rel&gt;</code>s
containing the final derived @output structs.</li>
<li><code>Crepe::run_with_hasher::&lt;S: BuildHasher + Default&gt;(self)</code>: similar to the
<code>run</code> method, but internally uses a custom hasher.</li>
</ul>
<p>In order for the engine to work, all relations must be tuple structs, and
they automatically derive the <code>Eq</code>, <code>PartialEq</code>, <code>Hash</code>, <code>Copy</code>, and
<code>Clone</code> traits. This is necessary in order to create efficient indices that
are used in Datalog evaluation. If you want to use Crepe with types that
do not implement <code>Copy</code>, consider passing references instead.</p>
<h2 id="datalog-syntax-extensions"><a href="#datalog-syntax-extensions">Datalog Syntax Extensions</a></h2>
<p>This library supports arbitrary Rust expression syntax within rules for
constructing new relations, as well as Boolean expressions that are
evaluated directly as clauses in rules. Basically, this gives you seamless
Rust interoperability within your Datalog programs.</p>
<p>For instance, here is a program that calculates the first 25 Fibonacci
numbers using arithmetic functors:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">crepe! </span>{
    @output
    <span class="kw">struct </span>Fib(u32, u32);

    Fib(<span class="number">0</span>, <span class="number">0</span>) &lt;- (<span class="bool-val">true</span>);
    Fib(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// shorthand for `Fib(1, 1) &lt;- (true);`

    </span>Fib(n + <span class="number">2</span>, x + y) &lt;- Fib(n, x), Fib(n + <span class="number">1</span>, y), (n + <span class="number">2 </span>&lt;= <span class="number">25</span>);
}</code></pre></div>
<p>Note that all Boolean conditions within the clauses of rules are evaluated
in-place, and they must be surrounded by parentheses.</p>
<p>We also support let-bindings in rules, including bindings that destructure
their arguments conditionally. See <code>tests/test_destructure.rs</code> for an
example of this.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">crepe! </span>{
    @input
    <span class="kw">struct </span>Value&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str);

    @output
    <span class="kw">struct </span>Squared(i32, i32);

    Squared(n, x) &lt;-
        Value(string),
        <span class="kw">let </span><span class="prelude-val">Ok</span>(n) = string.parse(),
        <span class="kw">let </span>x = n * n;
}</code></pre></div>
<p>The last built-in control flow feature is iteration over data. Rules can
enumerate values from an iterator, allowing them to use data from outside of
Crepe without having to convert functions to use work-arounds. For example,
to access the characters of a string, you could write:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">crepe! </span>{
    @input
    <span class="kw">struct </span>Name&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str);

    @output
    <span class="kw">struct </span>NameContainsLetter&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str, char);

    NameContainsLetter(name, letter) &lt;- Name(name), <span class="kw">for </span>letter <span class="kw">in </span>name.chars();
}</code></pre></div>
<h2 id="evaluation-mode"><a href="#evaluation-mode">Evaluation Mode</a></h2>
<p>All generated code uses semi-naive evaluation (see Chapter 3 of <em>Datalog
and Recursive Query Processing</em>), and it is split into multiple strata to
enable stratified negation. For example, we can extend the first example to
also compute the complement of transitive closure in a graph:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">mod </span>datalog {
    <span class="kw">use </span>crepe::crepe;

    <span class="macro">crepe! </span>{
        @input
        <span class="kw">struct </span>Edge(i32, i32);

        @output
        <span class="kw">struct </span>Tc(i32, i32);

        <span class="kw">struct </span>Node(i32);

        @output
        <span class="kw">struct </span>NotTc(i32, i32);

        Tc(x, y) &lt;- Edge(x, y);
        Tc(x, z) &lt;- Edge(x, y), Tc(y, z);

        Node(x) &lt;- Edge(x, <span class="kw">_</span>);
        Node(x) &lt;- Edge(<span class="kw">_</span>, x);
        NotTc(x, y) &lt;- Node(x), Node(y), !Tc(x, y);
    }

    <span class="kw">pub fn </span>run(edges: <span class="kw-2">&amp;</span>[(i32, i32)]) -&gt; (Vec&lt;(i32, i32)&gt;, Vec&lt;(i32, i32)&gt;) {
        <span class="kw">let </span><span class="kw-2">mut </span>runtime = Crepe::new();
        runtime.extend(edges.iter().map(|<span class="kw-2">&amp;</span>(a, b)| Edge(a, b)));
        <span class="kw">let </span>(tc, not_tc) = runtime.run();
        (
            tc.into_iter().map(|Tc(a, b)| (a, b)).collect(),
            not_tc.into_iter().map(|NotTc(a, b)| (a, b)).collect(),
        )
    }
}</code></pre></div>
<h2 id="lifetimes-and-attributes"><a href="#lifetimes-and-attributes">Lifetimes and Attributes</a></h2>
<p>This macro allows you to specify attributes, visibility modifiers, and
lifetimes on the relation structs. These can include additional <code>derive</code>
attributes, and lifetimes can be used to construct relations that include
non-owning references. The following example computes suffixes of words.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>crepe::crepe;

<span class="macro">crepe! </span>{
    @input
    <span class="kw">struct </span>Word&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str);

    @output
    <span class="attr">#[derive(Debug)]
    </span><span class="kw">struct </span>Suffix&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str);

    Suffix(w) &lt;- Word(w);
    Suffix(<span class="kw-2">&amp;</span>w[<span class="number">1</span>..]) &lt;- Suffix(w), (!w.is_empty());
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>runtime = Crepe::new();
    runtime.extend(<span class="kw-2">&amp;</span>[Word(<span class="string">&quot;banana&quot;</span>), Word(<span class="string">&quot;bandana&quot;</span>)]);
    <span class="kw">let </span>(suffixes,) = runtime.run();
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, suffixes);
}</code></pre></div>
<p>We also support the <code>ref</code> keyword for binding a variable by reference rather
than copying it, which can improve performance in some cases.</p>
<h2 id="hygiene"><a href="#hygiene">Hygiene</a></h2>
<p>In addition to the relation structs, this macro generates implementations
of a private struct named <code>Crepe</code> for the runtime. Therefore, it is
recommended to place each Datalog program within its own module, to prevent
name collisions.</p>
</div></details></section></div></main></body></html>